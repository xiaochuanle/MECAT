.\" Automatically generated by Pod::Man 2.22 (Pod::Simple 3.13)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Df 3"
.TH Df 3 "2006-06-25" "perl v5.10.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Filesys::Df \- Perl extension for filesystem disk space information.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Filesys::Df;
\&
\&  #### Get information by passing a scalar directory/filename value
\&  my $ref = df("/tmp");  # Default output is 1K blocks
\&  if(defined($ref)) {
\&     print "Total 1k blocks: $ref\->{blocks}\en";
\&     print "Total 1k blocks free: $ref\->{bfree}\en";
\&     print "Total 1k blocks avail to me: $ref\->{bavail}\en";
\&     print "Total 1k blocks used: $ref\->{used}\en";
\&     print "Percent full: $ref\->{per}\en";
\&
\&     if(exists($ref\->{files})) {
\&        print "Total inodes: $ref\->{files}\en"; 
\&        print "Total inodes free: $ref\->{ffree}\en"; 
\&        print "Inode percent full: $ref\->{fper}\en";
\&     }
\&  }
\&
\&  #### Get information by passing a filehandle
\&  open(FILE, "some_file");  # Get information for filesystem at "some_file"
\&  my $ref = df(\e*FILE);  
\&  #### or
\&  my $ref = df(*FILE);  
\&  #### or
\&  my $fhref = \e*FILE;
\&  my $ref = df($fhref);  
\&
\&  #### Get information in other than 1k blocks
\&  my $ref = df("/tmp", 8192);  # output is 8K blocks
\&  my $ref = df("/tmp", 1);     # output is bytes
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module provides a way to obtain filesystem disk space
information. This is a Unix only distribution. If you want to
gather this information for Unix and Windows, use \f(CW\*(C`Filesys::DfPortable\*(C'\fR.
The only major benefit of using \f(CW\*(C`Filesys::Df\*(C'\fR over \f(CW\*(C`Filesys::DfPortable\*(C'\fR,
is that \f(CW\*(C`Filesys::Df\*(C'\fR supports the use of open filehandles as arguments.
.PP
The module should work with all flavors of Unix that implement the
\&\f(CW\*(C`statvfs()\*(C'\fR and \f(CW\*(C`fstatvfs()\*(C'\fR calls, or the \f(CW\*(C`statfs()\*(C'\fR and \f(CW\*(C`fstatfs()\*(C'\fR calls.
This would include Linux, *BSD, HP-UX, \s-1AIX\s0, Solaris, Mac \s-1OS\s0 X, Irix,
Cygwin, etc ...
.PP
\&\f(CW\*(C`df()\*(C'\fR requires a argument that represents the filesystem you want to
query. The argument can be either a scalar directory/file name or a
open filehandle. There is also an optional block size argument so 
you can tailor the size of the values returned. The default block 
size is 1024. This will cause the function to return the values in 1k
blocks. If you want bytes, set the block size to 1.
.PP
\&\f(CW\*(C`df()\*(C'\fR returns a reference to a hash. The keys available in 
the hash are as follows:
.PP
\&\f(CW\*(C`{blocks}\*(C'\fR = Total blocks on the filesystem.
.PP
\&\f(CW\*(C`{bfree}\*(C'\fR = Total blocks free on the filesystem.
.PP
\&\f(CW\*(C`{bavail}\*(C'\fR = Total blocks available to the user executing the Perl 
application. This can be different than \f(CW\*(C`{bfree}\*(C'\fR if you have per-user 
quotas on the filesystem, or if the super user has a reserved amount.
\&\f(CW\*(C`{bavail}\*(C'\fR can also be a negative value because of this. For instance
if there is more space being used then you have available to you.
.PP
\&\f(CW\*(C`{used}\*(C'\fR = Total blocks used on the filesystem.
.PP
\&\f(CW\*(C`{per}\*(C'\fR = Percent of disk space used. This is based on the disk space
available to the user executing the application. In other words, if
the filesystem has 10% of its space reserved for the superuser, then
the percent used can go up to 110%.
.PP
You can obtain inode information through the module as well, but you
must call \f(CW\*(C`exists()\*(C'\fR on the \f(CW\*(C`{files}\*(C'\fR key first, to make sure the information 
is available. Some filesystems may not return inode information, for example
some \s-1NFS\s0 filesystems.
.PP
Here are the available inode keys:
.PP
\&\f(CW\*(C`{files}\*(C'\fR = Total inodes on the filesystem.
.PP
\&\f(CW\*(C`{ffree}\*(C'\fR = Total inodes free on the filesystem.
.PP
\&\f(CW\*(C`{favail}\*(C'\fR = Total inodes available to the user executing the application.
See the rules for the \f(CW\*(C`{bavail}\*(C'\fR key.
.PP
\&\f(CW\*(C`{fused}\*(C'\fR = Total inodes used on the filesystem.
.PP
\&\f(CW\*(C`{fper}\*(C'\fR = Percent of inodes used on the filesystem. See rules for the \f(CW\*(C`{per}\*(C'\fR
key.
.PP
There are some undocumented keys that are defined to maintain backwards
compatibilty: \f(CW\*(C`{su_blocks}\*(C'\fR, \f(CW\*(C`{user_blocks}\*(C'\fR, etc ...
.PP
If the \f(CW\*(C`df()\*(C'\fR call fails for any reason, it will return
undef. This will probably happen if you do anything crazy like try
to get information for /proc, or if you pass an invalid filesystem name,
or if there is an internal error. \f(CW\*(C`df()\*(C'\fR will \f(CW\*(C`croak()\*(C'\fR if you pass
it a undefined value.
.PP
Requirements:
Your system must contain \f(CW\*(C`statvfs()\*(C'\fR and \f(CW\*(C`fstatvfs()\*(C'\fR, or \f(CW\*(C`statfs()\*(C'\fR and \f(CW\*(C`fstatfs()\*(C'\fR
You must be running Perl 5.6 or higher.
.SH "AUTHOR"
.IX Header "AUTHOR"
Ian Guthrie
IGuthrie@aol.com
.PP
Copyright (c) 2006 Ian Guthrie. All rights reserved.
               This program is free software; you can redistribute it and/or
               modify it under the same terms as Perl itself.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIstatvfs\fR\|(2), \fIfstatvfs\fR\|(2), \fIstatfs\fR\|(2), \fIfstatfs\fR\|(2), \fIdf\fR\|(1), Filesys::DfPortable
.PP
\&\fIperl\fR\|(1).
